From aa1f676bf3ee88c70da6577db7212dc2efeb6313 Mon Sep 17 00:00:00 2001
From: Matteo Bertozzi <matteo.bertozzi@cloudera.com>
Date: Thu, 24 May 2012 19:46:54 +0200
Subject: [PATCH 049/151] HBASE-5849 On first cluster startup, RS aborts if root znode is not available

git-svn-id: https://svn.apache.org/repos/asf/hbase/branches/0.92@1329530 13f79535-47bb-0310-9956-ffa450edef68

Reason: Bug
Author: Enis Soztutar
Ref: CDH-5736
---
 .../hadoop/hbase/regionserver/HRegionServer.java   |    6 -
 .../apache/hadoop/hbase/TestClusterBootOrder.java  |  116 ++++++++++++++++++++
 2 files changed, 116 insertions(+), 6 deletions(-)
 create mode 100644 src/test/java/org/apache/hadoop/hbase/TestClusterBootOrder.java

diff --git a/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java b/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
index d907278..48183da 100644
--- a/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
+++ b/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
@@ -584,12 +584,6 @@ public class HRegionServer implements HRegionInterface, HBaseRPCErrorHandler,
    */
   private void blockAndCheckIfStopped(ZooKeeperNodeTracker tracker)
       throws IOException, InterruptedException {
-    if (false == tracker.checkIfBaseNodeAvailable()) {
-      String errorMsg = "Check the value configured in 'zookeeper.znode.parent'. "
-          + "There could be a mismatch with the one configured in the master.";
-      LOG.error(errorMsg);
-      abort(errorMsg);
-    }
     while (tracker.blockUntilAvailable(this.msgInterval, false) == null) {
       if (this.stopped) {
         throw new IOException("Received the shutdown message while waiting.");
diff --git a/src/test/java/org/apache/hadoop/hbase/TestClusterBootOrder.java b/src/test/java/org/apache/hadoop/hbase/TestClusterBootOrder.java
new file mode 100644
index 0000000..b7f3b49
--- /dev/null
+++ b/src/test/java/org/apache/hadoop/hbase/TestClusterBootOrder.java
@@ -0,0 +1,116 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hbase;
+
+import static org.junit.Assert.assertTrue;
+
+import org.apache.hadoop.hbase.util.JVMClusterUtil.MasterThread;
+import org.apache.hadoop.hbase.util.JVMClusterUtil.RegionServerThread;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+/**
+ * Tests the boot order indifference between regionserver and master
+ */
+public class TestClusterBootOrder {
+
+  private static final long SLEEP_INTERVAL = 1000;
+  private static final long SLEEP_TIME = 4000;
+
+  private HBaseTestingUtility testUtil;
+  private LocalHBaseCluster cluster;
+  private RegionServerThread rs;
+  private MasterThread master;
+
+  @Before
+  public void setUp() throws Exception {
+    testUtil = new HBaseTestingUtility();
+    testUtil.startMiniDFSCluster(1);
+    testUtil.startMiniZKCluster(1);
+    testUtil.createRootDir(); //manually setup hbase dir to point to minidfscluster
+    cluster = new LocalHBaseCluster(testUtil.getConfiguration(), 0, 0);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    cluster.shutdown();
+    cluster.join();
+    testUtil.shutdownMiniZKCluster();
+    testUtil.shutdownMiniDFSCluster();
+  }
+
+  private void startRegionServer() throws Exception {
+    rs = cluster.addRegionServer();
+    rs.start();
+
+    for (int i=0; i * SLEEP_INTERVAL < SLEEP_TIME ;i++) {
+      //we cannot block on wait for rs at this point , since master is not up.
+      Thread.sleep(SLEEP_INTERVAL);
+      assertTrue(rs.isAlive());
+    }
+  }
+
+  private void startMaster() throws Exception {
+    master = cluster.addMaster();
+    master.start();
+
+    for (int i=0; i * SLEEP_INTERVAL < SLEEP_TIME ;i++) {
+      Thread.sleep(SLEEP_INTERVAL);
+      assertTrue(master.isAlive());
+    }
+  }
+
+  private void waitForClusterOnline() {
+    while (true) {
+      if (master.getMaster().isInitialized()) {
+        break;
+      }
+      try {
+        Thread.sleep(100);
+      } catch (InterruptedException ignored) {
+        // Keep waiting
+      }
+    }
+    rs.waitForServerOnline();
+  }
+
+  /**
+   * Tests launching the cluster by first starting regionserver, and then the master
+   * to ensure that it does not matter which is started first.
+   */
+  @Test
+  public void testBootRegionServerFirst() throws Exception {
+    startRegionServer();
+    startMaster();
+    waitForClusterOnline();
+  }
+
+  /**
+   * Tests launching the cluster by first starting master, and then the regionserver
+   * to ensure that it does not matter which is started first.
+   */
+  @Test
+  public void testBootMasterFirst() throws Exception {
+    startMaster();
+    startRegionServer();
+    waitForClusterOnline();
+  }
+}
-- 
1.7.0.4

