From 965d7549573eae84d581cae6d5a734e861bd1dc3 Mon Sep 17 00:00:00 2001
From: Gregory Chanan <gchanan@cloudera.com>
Date: Thu, 26 Jul 2012 18:16:20 -0700
Subject: [PATCH 088/154] HBASE-6334 TestImprovement for TestHRegion.testWritesWhileGetting

Reason: Backport
Author: Gregory Chanan
Ref: CDH-6929
---
 .../hadoop/hbase/regionserver/TestHRegion.java     |   68 ++++++++++++--------
 1 files changed, 40 insertions(+), 28 deletions(-)

diff --git a/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java b/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
index 7b33f40..7cd3218 100644
--- a/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
+++ b/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java
@@ -50,6 +50,7 @@ import org.apache.hadoop.hbase.HTableDescriptor;
 import org.apache.hadoop.hbase.KeyValue;
 import org.apache.hadoop.hbase.MultithreadedTestUtil;
 import org.apache.hadoop.hbase.MultithreadedTestUtil.TestThread;
+import org.apache.hadoop.hbase.MultithreadedTestUtil.RepeatingTestThread;
 import org.apache.hadoop.hbase.MiniHBaseCluster;
 import org.apache.hadoop.hbase.client.Delete;
 import org.apache.hadoop.hbase.client.Get;
@@ -3091,21 +3092,19 @@ public class TestHRegion extends HBaseTestCase {
 
   /**
    * Writes very wide records and gets the latest row every time..
-   * Flushes and compacts the region every now and then to keep things
-   * realistic.
+   * Flushes and compacts the region aggressivly to catch issues.
    *
    * @throws IOException          by flush / scan / compaction
    * @throws InterruptedException when joining threads
    */
   public void testWritesWhileGetting()
-    throws IOException, InterruptedException {
-    byte[] tableName = Bytes.toBytes("testWritesWhileScanning");
+    throws Exception {
+    byte[] tableName = Bytes.toBytes("testWritesWhileGetting");
     int testCount = 100;
     int numRows = 1;
     int numFamilies = 10;
     int numQualifiers = 100;
-    int flushInterval = 10;
-    int compactInterval = 10 * flushInterval;
+    int compactInterval = 100;
     byte[][] families = new byte[numFamilies][];
     for (int i = 0; i < numFamilies; i++) {
       families[i] = Bytes.toBytes("family" + i);
@@ -3116,14 +3115,37 @@ public class TestHRegion extends HBaseTestCase {
     }
 
     String method = "testWritesWhileGetting";
-    this.region = initHRegion(tableName, method, families);
+    Configuration conf = HBaseConfiguration.create();
+    // This test flushes constantly and can cause many files to be created, possibly
+    // extending over the ulimit.  Make sure compactions are aggressive in reducing
+    // the number of HFiles created.
+    conf.setInt("hbase.hstore.compaction.min", 1);
+    conf.setInt("hbase.hstore.compaction.max", 1000);
+    this.region = initHRegion(tableName, method, conf, families);
+    PutThread putThread = null;
+    MultithreadedTestUtil.TestContext ctx =
+      new MultithreadedTestUtil.TestContext(HBaseConfiguration.create());
     try {
-      PutThread putThread = new PutThread(numRows, families, qualifiers);
+      putThread = new PutThread(numRows, families, qualifiers);
       putThread.start();
       putThread.waitForFirstPut();
 
-      FlushThread flushThread = new FlushThread();
-      flushThread.start();
+      // Add a thread that flushes as fast as possible
+      ctx.addThread(new RepeatingTestThread(ctx) {
+    	private int flushesSinceCompact = 0;
+    	private final int maxFlushesSinceCompact = 20;
+        public void doAnAction() throws Exception {
+          if (region.flushcache()) {
+            ++flushesSinceCompact;
+          }
+          // Compact regularly to avoid creating too many files and exceeding the ulimit.
+          if (flushesSinceCompact == maxFlushesSinceCompact) {
+            region.compactStores(false);
+            flushesSinceCompact = 0;
+          }
+        }
+      });
+      ctx.startThreads();
 
       Get get = new Get(Bytes.toBytes("row0"));
       Result result = null;
@@ -3133,15 +3155,6 @@ public class TestHRegion extends HBaseTestCase {
       long prevTimestamp = 0L;
       for (int i = 0; i < testCount; i++) {
 
-        if (i != 0 && i % compactInterval == 0) {
-          region.compactStores(true);
-        }
-
-        if (i != 0 && i % flushInterval == 0) {
-          //System.out.println("iteration = " + i);
-          flushThread.flush();
-        }
-
         boolean previousEmpty = result == null || result.isEmpty();
         result = region.get(get, null);
         if (!result.isEmpty() || !previousEmpty || i > compactInterval) {
@@ -3169,25 +3182,24 @@ public class TestHRegion extends HBaseTestCase {
                     ", New KV: " +
                     kv + "(memStoreTS:" + kv.getMemstoreTS() + ")"
                     );
-                assertEquals(previousKV.getValue(), thisValue);
+                assertEquals(0, Bytes.compareTo(previousKV.getValue(), thisValue));
               }
             }
             previousKV = kv;
           }
         }
       }
-
-      putThread.done();
+    } finally {
+      if (putThread != null) putThread.done();
 
       region.flushcache();
 
-      putThread.join();
-      putThread.checkNoError();
+      if (putThread != null) {
+        putThread.join();
+        putThread.checkNoError();
+      }
 
-      flushThread.done();
-      flushThread.join();
-      flushThread.checkNoError();
-    } finally {
+      ctx.stop();
       HRegion.closeHRegion(this.region);
       this.region = null;
     }
-- 
1.7.0.4

