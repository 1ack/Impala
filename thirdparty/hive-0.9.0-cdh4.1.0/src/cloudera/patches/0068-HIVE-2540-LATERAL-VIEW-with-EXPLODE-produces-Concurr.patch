From a31968c22a3be393844b897f40c0008a9bbecba9 Mon Sep 17 00:00:00 2001
From: Namit Jain <namit@apache.org>
Date: Sun, 27 May 2012 12:07:50 +0000
Subject: [PATCH 068/144] HIVE-2540 LATERAL VIEW with EXPLODE produces ConcurrentModificationException
 (Navis via namit)

git-svn-id: https://svn.apache.org/repos/asf/hive/trunk@1343036 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 6e46d51efe0b83a4b4109b8545099bf0ec6174de)
---
 ql/src/test/queries/clientpositive/udf_explode.q   |    9 ++-
 ql/src/test/queries/clientpositive/udtf_explode.q  |    5 +-
 .../test/results/clientpositive/udf_explode.q.out  |   45 +++++++++++++
 .../test/results/clientpositive/udtf_explode.q.out |   22 ++++++
 .../apache/hadoop/hive/serde2/lazy/LazyArray.java  |   33 ++++-----
 .../apache/hadoop/hive/serde2/lazy/LazyMap.java    |   68 +++++++++----------
 6 files changed, 126 insertions(+), 56 deletions(-)

diff --git a/src/ql/src/test/queries/clientpositive/udf_explode.q b/src/ql/src/test/queries/clientpositive/udf_explode.q
index e37ced6..19af288 100644
--- a/src/ql/src/test/queries/clientpositive/udf_explode.q
+++ b/src/ql/src/test/queries/clientpositive/udf_explode.q
@@ -12,4 +12,11 @@ EXPLAIN EXTENDED SELECT explode(map(1,'one',2,'two',3,'three')) AS (key,val) FRO
 EXPLAIN EXTENDED SELECT a.key, a.val, count(1) FROM (SELECT explode(map(1,'one',2,'two',3,'three')) AS (key,val) FROM src LIMIT 3) a GROUP BY a.key, a.val;
 
 SELECT explode(map(1,'one',2,'two',3,'three')) AS (key,val) FROM src LIMIT 3;
-SELECT a.key, a.val, count(1) FROM (SELECT explode(map(1,'one',2,'two',3,'three')) AS (key,val) FROM src LIMIT 3) a GROUP BY a.key, a.val;
\ No newline at end of file
+SELECT a.key, a.val, count(1) FROM (SELECT explode(map(1,'one',2,'two',3,'three')) AS (key,val) FROM src LIMIT 3) a GROUP BY a.key, a.val;
+
+drop table lazy_array_map;
+create table lazy_array_map (map_col map<int,string>, array_col array<string>);
+INSERT OVERWRITE TABLE lazy_array_map select map(1,'one',2,'two',3,'three'), array('100','200','300') FROM src LIMIT 1;
+
+SELECT array_col, myCol from lazy_array_map lateral view explode(array_col) X AS myCol;
+SELECT map_col, myKey, myValue from lazy_array_map lateral view explode(map_col) X AS myKey, myValue;
\ No newline at end of file
diff --git a/src/ql/src/test/queries/clientpositive/udtf_explode.q b/src/ql/src/test/queries/clientpositive/udtf_explode.q
index eb5ab5a..9d732c7 100644
--- a/src/ql/src/test/queries/clientpositive/udtf_explode.q
+++ b/src/ql/src/test/queries/clientpositive/udtf_explode.q
@@ -12,4 +12,7 @@ EXPLAIN SELECT explode(map(1,'one',2,'two',3,'three')) as (myKey,myVal) FROM src
 EXPLAIN EXTENDED SELECT a.myKey, a.myVal, count(1) FROM (SELECT explode(map(1,'one',2,'two',3,'three')) as (myKey,myVal) FROM src LIMIT 3) a GROUP BY a.myKey, a.myVal;
 
 SELECT explode(map(1,'one',2,'two',3,'three')) as (myKey,myVal) FROM src LIMIT 3;
-SELECT a.myKey, a.myVal, count(1) FROM (SELECT explode(map(1,'one',2,'two',3,'three')) as (myKey,myVal) FROM src LIMIT 3) a GROUP BY a.myKey, a.myVal;
\ No newline at end of file
+SELECT a.myKey, a.myVal, count(1) FROM (SELECT explode(map(1,'one',2,'two',3,'three')) as (myKey,myVal) FROM src LIMIT 3) a GROUP BY a.myKey, a.myVal;
+
+SELECT src.key, myCol FROM src lateral view explode(array(1,2,3)) x AS myCol LIMIT 3;
+SELECT src.key, myKey, myVal FROM src lateral view explode(map(1,'one',2,'two',3,'three')) x AS myKey,myVal LIMIT 3;
\ No newline at end of file
diff --git a/src/ql/src/test/results/clientpositive/udf_explode.q.out b/src/ql/src/test/results/clientpositive/udf_explode.q.out
index 58540c8..41fb6da 100644
--- a/src/ql/src/test/results/clientpositive/udf_explode.q.out
+++ b/src/ql/src/test/results/clientpositive/udf_explode.q.out
@@ -607,3 +607,48 @@ POSTHOOK: Input: default@src
 1	one	1
 2	two	1
 3	three	1
+PREHOOK: query: drop table lazy_array_map
+PREHOOK: type: DROPTABLE
+POSTHOOK: query: drop table lazy_array_map
+POSTHOOK: type: DROPTABLE
+PREHOOK: query: create table lazy_array_map (map_col map<int,string>, array_col array<string>)
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: create table lazy_array_map (map_col map<int,string>, array_col array<string>)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: default@lazy_array_map
+PREHOOK: query: INSERT OVERWRITE TABLE lazy_array_map select map(1,'one',2,'two',3,'three'), array('100','200','300') FROM src LIMIT 1
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+PREHOOK: Output: default@lazy_array_map
+POSTHOOK: query: INSERT OVERWRITE TABLE lazy_array_map select map(1,'one',2,'two',3,'three'), array('100','200','300') FROM src LIMIT 1
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+POSTHOOK: Output: default@lazy_array_map
+POSTHOOK: Lineage: lazy_array_map.array_col EXPRESSION []
+POSTHOOK: Lineage: lazy_array_map.map_col EXPRESSION []
+PREHOOK: query: SELECT array_col, myCol from lazy_array_map lateral view explode(array_col) X AS myCol
+PREHOOK: type: QUERY
+PREHOOK: Input: default@lazy_array_map
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT array_col, myCol from lazy_array_map lateral view explode(array_col) X AS myCol
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@lazy_array_map
+#### A masked pattern was here ####
+POSTHOOK: Lineage: lazy_array_map.array_col EXPRESSION []
+POSTHOOK: Lineage: lazy_array_map.map_col EXPRESSION []
+["100","200","300"]	100
+["100","200","300"]	200
+["100","200","300"]	300
+PREHOOK: query: SELECT map_col, myKey, myValue from lazy_array_map lateral view explode(map_col) X AS myKey, myValue
+PREHOOK: type: QUERY
+PREHOOK: Input: default@lazy_array_map
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT map_col, myKey, myValue from lazy_array_map lateral view explode(map_col) X AS myKey, myValue
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@lazy_array_map
+#### A masked pattern was here ####
+POSTHOOK: Lineage: lazy_array_map.array_col EXPRESSION []
+POSTHOOK: Lineage: lazy_array_map.map_col EXPRESSION []
+{1:"one",2:"two",3:"three"}	1	one
+{1:"one",2:"two",3:"three"}	2	two
+{1:"one",2:"two",3:"three"}	3	three
diff --git a/src/ql/src/test/results/clientpositive/udtf_explode.q.out b/src/ql/src/test/results/clientpositive/udtf_explode.q.out
index f606ff2..63c5f5f 100644
--- a/src/ql/src/test/results/clientpositive/udtf_explode.q.out
+++ b/src/ql/src/test/results/clientpositive/udtf_explode.q.out
@@ -559,3 +559,25 @@ POSTHOOK: Input: default@src
 1	one	1
 2	two	1
 3	three	1
+PREHOOK: query: SELECT src.key, myCol FROM src lateral view explode(array(1,2,3)) x AS myCol LIMIT 3
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT src.key, myCol FROM src lateral view explode(array(1,2,3)) x AS myCol LIMIT 3
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+238	1
+238	2
+238	3
+PREHOOK: query: SELECT src.key, myKey, myVal FROM src lateral view explode(map(1,'one',2,'two',3,'three')) x AS myKey,myVal LIMIT 3
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+#### A masked pattern was here ####
+POSTHOOK: query: SELECT src.key, myKey, myVal FROM src lateral view explode(map(1,'one',2,'two',3,'three')) x AS myKey,myVal LIMIT 3
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+#### A masked pattern was here ####
+238	1	one
+238	2	two
+238	3	three
diff --git a/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java b/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java
index 885a261..94327b7 100644
--- a/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java
+++ b/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyArray.java
@@ -22,12 +22,11 @@ import java.util.Arrays;
 import java.util.List;
 
 import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyListObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.ListObjectInspector;
 import org.apache.hadoop.io.Text;
 
 /**
  * LazyArray stores an array of Lazy Objects.
- * 
+ *
  * LazyArray does not deal with the case of a NULL array. That is handled by the
  * parent LazyObject.
  */
@@ -64,7 +63,7 @@ public class LazyArray extends LazyNonPrimitive<LazyListObjectInspector> {
 
   /**
    * Construct a LazyArray object with the ObjectInspector.
-   * 
+   *
    * @param oi
    *          the oi representing the type of this LazyArray as well as meta
    *          information like separator etc.
@@ -75,13 +74,14 @@ public class LazyArray extends LazyNonPrimitive<LazyListObjectInspector> {
 
   /**
    * Set the row data for this LazyArray.
-   * 
+   *
    * @see LazyObject#init(ByteArrayRef, int, int)
    */
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
     super.init(bytes, start, length);
     parsed = false;
+    cachedList = null;
   }
 
   /**
@@ -175,6 +175,11 @@ public class LazyArray extends LazyNonPrimitive<LazyListObjectInspector> {
    * Get the element without checking out-of-bound index.
    */
   private Object uncheckedGetElement(int index) {
+    if (elementInited[index]) {
+      return arrayElements[index] == null ? null : arrayElements[index].getObject();
+    }
+    elementInited[index] = true;
+
     Text nullSequence = oi.getNullSequence();
 
     int elementLength = startPosition[index + 1] - startPosition[index] - 1;
@@ -183,17 +188,10 @@ public class LazyArray extends LazyNonPrimitive<LazyListObjectInspector> {
         .compare(bytes.getData(), startPosition[index], elementLength,
         nullSequence.getBytes(), 0, nullSequence.getLength())) {
       return null;
-    } else {
-      if (!elementInited[index]) {
-        elementInited[index] = true;
-        if (arrayElements[index] == null) {
-          arrayElements[index] = LazyFactory
-              .createLazyObject(((ListObjectInspector) oi)
-              .getListElementObjectInspector());
-        }
-        arrayElements[index].init(bytes, startPosition[index], elementLength);
-      }
     }
+    arrayElements[index] = LazyFactory
+        .createLazyObject(oi.getListElementObjectInspector());
+    arrayElements[index].init(bytes, startPosition[index], elementLength);
     return arrayElements[index].getObject();
   }
 
@@ -223,11 +221,10 @@ public class LazyArray extends LazyNonPrimitive<LazyListObjectInspector> {
     if (arrayLength == -1) {
       return null;
     }
-    if (cachedList == null) {
-      cachedList = new ArrayList<Object>(arrayLength);
-    } else {
-      cachedList.clear();
+    if (cachedList != null) {
+      return cachedList;
     }
+    cachedList = new ArrayList<Object>(arrayLength);
     for (int index = 0; index < arrayLength; index++) {
       cachedList.add(uncheckedGetElement(index));
     }
diff --git a/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java b/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java
index 637ce80..84c2a5e 100644
--- a/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java
+++ b/src/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazyMap.java
@@ -22,14 +22,13 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 
 import org.apache.hadoop.hive.serde2.lazy.objectinspector.LazyMapObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.MapObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;
 import org.apache.hadoop.io.Text;
 
 /**
  * LazyMap stores a map of Primitive LazyObjects to LazyObjects. Note that the
  * keys of the map cannot contain null.
- * 
+ *
  * LazyMap does not deal with the case of a NULL map. That is handled by the
  * parent LazyObject.
  */
@@ -85,13 +84,14 @@ public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
 
   /**
    * Set the row data for this LazyArray.
-   * 
+   *
    * @see LazyObject#init(ByteArrayRef, int, int)
    */
   @Override
   public void init(ByteArrayRef bytes, int start, int length) {
     super.init(bytes, start, length);
     parsed = false;
+    cachedMap = null;
   }
 
   /**
@@ -188,15 +188,15 @@ public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
 
   /**
    * Get the value in the map for the key.
-   * 
+   *
    * If there are multiple matches (which is possible in the serialized format),
    * only the first one is returned.
-   * 
+   *
    * The most efficient way to get the value for the key is to serialize the key
    * and then try to find it in the array. We do linear search because in most
    * cases, user only wants to get one or two values out of the map, and the
    * cost of building up a HashMap is substantially higher.
-   * 
+   *
    * @param key
    *          The key object that we are looking for.
    * @return The corresponding value object, or NULL if not found
@@ -229,11 +229,15 @@ public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
 
   /**
    * Get the value object with the index without checking parsed.
-   * 
+   *
    * @param index
    *          The index into the array starting from 0
    */
   private LazyObject uncheckedGetValue(int index) {
+    if (valueInited[index]) {
+      return valueObjects[index];
+    }
+    valueInited[index] = true;
     Text nullSequence = oi.getNullSequence();
     int valueIBegin = keyEnd[index] + 1;
     int valueILength = keyStart[index + 1] - 1 - valueIBegin;
@@ -241,27 +245,26 @@ public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
         || ((valueILength == nullSequence.getLength()) && 0 == LazyUtils
         .compare(bytes.getData(), valueIBegin, valueILength, nullSequence
         .getBytes(), 0, nullSequence.getLength()))) {
-      return null;
-    }
-    if (!valueInited[index]) {
-      valueInited[index] = true;
-      if (valueObjects[index] == null) {
-        valueObjects[index] = LazyFactory
-            .createLazyObject(((MapObjectInspector) oi)
-            .getMapValueObjectInspector());
-      }
-      valueObjects[index].init(bytes, valueIBegin, valueILength);
+      return valueObjects[index] = null;
     }
+    valueObjects[index] = LazyFactory
+        .createLazyObject(oi.getMapValueObjectInspector());
+    valueObjects[index].init(bytes, valueIBegin, valueILength);
     return valueObjects[index];
   }
 
   /**
    * Get the key object with the index without checking parsed.
-   * 
+   *
    * @param index
    *          The index into the array starting from 0
    */
   private LazyPrimitive<?, ?> uncheckedGetKey(int index) {
+    if (keyInited[index]) {
+      return keyObjects[index];
+    }
+    keyInited[index] = true;
+
     Text nullSequence = oi.getNullSequence();
     int keyIBegin = keyStart[index];
     int keyILength = keyEnd[index] - keyStart[index];
@@ -269,18 +272,12 @@ public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
         || ((keyILength == nullSequence.getLength()) && 0 == LazyUtils.compare(
         bytes.getData(), keyIBegin, keyILength, nullSequence.getBytes(), 0,
         nullSequence.getLength()))) {
-      return null;
-    }
-    if (!keyInited[index]) {
-      keyInited[index] = true;
-      if (keyObjects[index] == null) {
-        // Keys are always primitive
-        keyObjects[index] = LazyFactory
-            .createLazyPrimitiveClass((PrimitiveObjectInspector) ((MapObjectInspector) oi)
-            .getMapKeyObjectInspector());
-      }
-      keyObjects[index].init(bytes, keyIBegin, keyILength);
+      return keyObjects[index] = null;
     }
+    // Keys are always primitive
+    keyObjects[index] = LazyFactory
+        .createLazyPrimitiveClass((PrimitiveObjectInspector) oi.getMapKeyObjectInspector());
+    keyObjects[index].init(bytes, keyIBegin, keyILength);
     return keyObjects[index];
   }
 
@@ -293,19 +290,18 @@ public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
   /**
    * Return the map object representing this LazyMap. Note that the keyObjects
    * will be Writable primitive objects.
-   * 
+   *
    * @return the map object
    */
   public Map<Object, Object> getMap() {
     if (!parsed) {
       parse();
     }
-    if (cachedMap == null) {
-      // Use LinkedHashMap to provide deterministic order
-      cachedMap = new LinkedHashMap<Object, Object>();
-    } else {
-      cachedMap.clear();
+    if (cachedMap != null) {
+      return cachedMap;
     }
+    // Use LinkedHashMap to provide deterministic order
+    cachedMap = new LinkedHashMap<Object, Object>();
 
     // go through each element of the map
     for (int i = 0; i < mapSize; i++) {
@@ -326,7 +322,7 @@ public class LazyMap extends LazyNonPrimitive<LazyMapObjectInspector> {
 
   /**
    * Get the size of the map represented by this LazyMap.
-   * 
+   *
    * @return The size of the map, -1 for NULL map.
    */
   public int getMapSize() {
-- 
1.7.0.4

