From 182ddf257d7a6a869c5b83122f20ff08ab1b0114 Mon Sep 17 00:00:00 2001
From: Edward Capriolo <ecapriolo@apache.org>
Date: Wed, 13 Jun 2012 15:37:32 +0000
Subject: [PATCH 089/148] HIVE-3090 Timestamp types not having nano-second part breaks row (Navis via egc)

git-svn-id: https://svn.apache.org/repos/asf/hive/trunk@1349907 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 9bc918059d53039736dbd0e0aae643c7bf5953a4)
---
 .../test/queries/clientpositive/timestamp_lazy.q   |    6 ++
 .../results/clientpositive/timestamp_lazy.q.out    |   52 ++++++++++++++++++++
 .../hadoop/hive/serde2/io/TimestampWritable.java   |   15 ++++--
 3 files changed, 69 insertions(+), 4 deletions(-)
 create mode 100644 ql/src/test/queries/clientpositive/timestamp_lazy.q
 create mode 100644 ql/src/test/results/clientpositive/timestamp_lazy.q.out

diff --git a/src/ql/src/test/queries/clientpositive/timestamp_lazy.q b/src/ql/src/test/queries/clientpositive/timestamp_lazy.q
new file mode 100644
index 0000000..2b42a43
--- /dev/null
+++ b/src/ql/src/test/queries/clientpositive/timestamp_lazy.q
@@ -0,0 +1,6 @@
+drop table timestamp_lazy;
+create table timestamp_lazy (t timestamp, key string, value string);
+insert overwrite table timestamp_lazy select cast('2011-01-01 01:01:01' as timestamp), key, value from src limit 5;
+
+select t,key,value from timestamp_lazy;
+select t,key,value from timestamp_lazy distribute by t;
\ No newline at end of file
diff --git a/src/ql/src/test/results/clientpositive/timestamp_lazy.q.out b/src/ql/src/test/results/clientpositive/timestamp_lazy.q.out
new file mode 100644
index 0000000..9f68281
--- /dev/null
+++ b/src/ql/src/test/results/clientpositive/timestamp_lazy.q.out
@@ -0,0 +1,52 @@
+PREHOOK: query: drop table timestamp_lazy
+PREHOOK: type: DROPTABLE
+POSTHOOK: query: drop table timestamp_lazy
+POSTHOOK: type: DROPTABLE
+PREHOOK: query: create table timestamp_lazy (t timestamp, key string, value string)
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: create table timestamp_lazy (t timestamp, key string, value string)
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: default@timestamp_lazy
+PREHOOK: query: insert overwrite table timestamp_lazy select cast('2011-01-01 01:01:01' as timestamp), key, value from src limit 5
+PREHOOK: type: QUERY
+PREHOOK: Input: default@src
+PREHOOK: Output: default@timestamp_lazy
+POSTHOOK: query: insert overwrite table timestamp_lazy select cast('2011-01-01 01:01:01' as timestamp), key, value from src limit 5
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@src
+POSTHOOK: Output: default@timestamp_lazy
+POSTHOOK: Lineage: timestamp_lazy.key SIMPLE [(src)src.FieldSchema(name:key, type:string, comment:default), ]
+POSTHOOK: Lineage: timestamp_lazy.t EXPRESSION []
+POSTHOOK: Lineage: timestamp_lazy.value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
+PREHOOK: query: select t,key,value from timestamp_lazy
+PREHOOK: type: QUERY
+PREHOOK: Input: default@timestamp_lazy
+#### A masked pattern was here ####
+POSTHOOK: query: select t,key,value from timestamp_lazy
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@timestamp_lazy
+#### A masked pattern was here ####
+POSTHOOK: Lineage: timestamp_lazy.key SIMPLE [(src)src.FieldSchema(name:key, type:string, comment:default), ]
+POSTHOOK: Lineage: timestamp_lazy.t EXPRESSION []
+POSTHOOK: Lineage: timestamp_lazy.value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
+2011-01-01 01:01:01	238	val_238
+2011-01-01 01:01:01	86	val_86
+2011-01-01 01:01:01	311	val_311
+2011-01-01 01:01:01	27	val_27
+2011-01-01 01:01:01	165	val_165
+PREHOOK: query: select t,key,value from timestamp_lazy distribute by t
+PREHOOK: type: QUERY
+PREHOOK: Input: default@timestamp_lazy
+#### A masked pattern was here ####
+POSTHOOK: query: select t,key,value from timestamp_lazy distribute by t
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@timestamp_lazy
+#### A masked pattern was here ####
+POSTHOOK: Lineage: timestamp_lazy.key SIMPLE [(src)src.FieldSchema(name:key, type:string, comment:default), ]
+POSTHOOK: Lineage: timestamp_lazy.t EXPRESSION []
+POSTHOOK: Lineage: timestamp_lazy.value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
+2011-01-01 01:01:01	238	val_238
+2011-01-01 01:01:01	86	val_86
+2011-01-01 01:01:01	311	val_311
+2011-01-01 01:01:01	27	val_27
+2011-01-01 01:01:01	165	val_165
diff --git a/src/serde/src/java/org/apache/hadoop/hive/serde2/io/TimestampWritable.java b/src/serde/src/java/org/apache/hadoop/hive/serde2/io/TimestampWritable.java
index 513f685..daab98d 100644
--- a/src/serde/src/java/org/apache/hadoop/hive/serde2/io/TimestampWritable.java
+++ b/src/serde/src/java/org/apache/hadoop/hive/serde2/io/TimestampWritable.java
@@ -166,7 +166,7 @@ public class TimestampWritable implements WritableComparable<TimestampWritable>
       return timestamp.getNanos();
     }
 
-    return TimestampWritable.getNanos(currentBytes, offset+4);
+    return hasDecimal() ? TimestampWritable.getNanos(currentBytes, offset+4) : 0;
   }
 
   /**
@@ -183,7 +183,7 @@ public class TimestampWritable implements WritableComparable<TimestampWritable>
    */
   private int getDecimalLength() {
     checkBytes();
-    return WritableUtils.decodeVIntSize(currentBytes[offset+4]);
+    return hasDecimal() ? WritableUtils.decodeVIntSize(currentBytes[offset+4]) : 0;
   }
 
   public Timestamp getTimestamp() {
@@ -393,7 +393,7 @@ public class TimestampWritable implements WritableComparable<TimestampWritable>
     long millis = t.getTime();
     int nanos = t.getNanos();
 
-    boolean hasDecimal = setNanosBytes(nanos, b, offset+4);
+    boolean hasDecimal = nanos != 0 && setNanosBytes(nanos, b, offset+4);
     setSecondsBytes(millis, b, offset, hasDecimal);
   }
 
@@ -471,8 +471,11 @@ public class TimestampWritable implements WritableComparable<TimestampWritable>
   }
 
   public static void setTimestamp(Timestamp t, byte[] bytes, int offset) {
+    boolean hasDecimal = hasDecimal(bytes[offset]);
     t.setTime(((long) TimestampWritable.getSeconds(bytes, offset)) * 1000);
-    t.setNanos(TimestampWritable.getNanos(bytes, offset+4));
+    if (hasDecimal) {
+      t.setNanos(TimestampWritable.getNanos(bytes, offset+4));
+    }
   }
 
   public static Timestamp createTimestamp(byte[] bytes, int offset) {
@@ -481,6 +484,10 @@ public class TimestampWritable implements WritableComparable<TimestampWritable>
     return t;
   }
 
+  public boolean hasDecimal() {
+    return hasDecimal(currentBytes[offset]);
+  }
+
   /**
    *
    * @param b first byte in an encoded TimestampWritable
-- 
1.7.0.4

