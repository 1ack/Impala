From b0ec04351898a5ee7153d02837950f5cbd5afd86 Mon Sep 17 00:00:00 2001
From: Jimmy Xiang <jxiang@cloudera.com>
Date: Thu, 17 May 2012 10:43:06 -0700
Subject: [PATCH 35/36] HBASE-6004 Adding more logging to help debugging MR job

Reason: Improvement
Author: Jimmy Xiang
Ref: CDH-5889
---
 .../hadoop/hbase/client/ScannerCallable.java       |   43 +++++++++-
 .../hadoop/hbase/mapred/TableRecordReaderImpl.java |   91 ++++++++++++++-----
 .../hbase/mapreduce/TableRecordReaderImpl.java     |   86 ++++++++++++++-----
 3 files changed, 172 insertions(+), 48 deletions(-)

diff --git a/src/main/java/org/apache/hadoop/hbase/client/ScannerCallable.java b/src/main/java/org/apache/hadoop/hbase/client/ScannerCallable.java
index cd8411a..6c4885f 100644
--- a/src/main/java/org/apache/hadoop/hbase/client/ScannerCallable.java
+++ b/src/main/java/org/apache/hadoop/hbase/client/ScannerCallable.java
@@ -24,10 +24,13 @@ import java.io.IOException;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.HRegionLocation;
 import org.apache.hadoop.hbase.NotServingRegionException;
 import org.apache.hadoop.hbase.RemoteExceptionHandler;
+import org.apache.hadoop.hbase.UnknownScannerException;
 import org.apache.hadoop.hbase.regionserver.RegionServerStoppedException;
 import org.apache.hadoop.ipc.RemoteException;
 
@@ -37,12 +40,17 @@ import org.apache.hadoop.ipc.RemoteException;
  * Used by {@link ResultScanner}s made by {@link HTable}.
  */
 public class ScannerCallable extends ServerCallable<Result[]> {
+  public static final String LOG_SCANNER_LATENCY_CUTOFF
+    = "hbase.client.log.scanner.latency.cutoff";
+  public static final String LOG_SCANNER_ACTIVITY = "hbase.client.log.scanner.activity";
   private static final Log LOG = LogFactory.getLog(ScannerCallable.class);
   private long scannerId = -1L;
   private boolean instantiated = false;
   private boolean closed = false;
   private Scan scan;
   private int caching = 1;
+  private boolean logScannerActivity = false;
+  private int logCutOffLatency = 1000;
 
   /**
    * @param connection which connection
@@ -52,6 +60,9 @@ public class ScannerCallable extends ServerCallable<Result[]> {
   public ScannerCallable (HConnection connection, byte [] tableName, Scan scan) {
     super(connection, tableName, scan.getStartRow());
     this.scan = scan;
+    Configuration conf = connection.getConfiguration();
+    logScannerActivity = conf.getBoolean(LOG_SCANNER_ACTIVITY, false);
+    logCutOffLatency = conf.getInt(LOG_SCANNER_LATENCY_CUTOFF, 1000);
   }
 
   /**
@@ -77,13 +88,37 @@ public class ScannerCallable extends ServerCallable<Result[]> {
     } else {
       Result [] rrs = null;
       try {
+        long timestamp = System.currentTimeMillis();
         rrs = server.next(scannerId, caching);
+        if (logScannerActivity) {
+          long now = System.currentTimeMillis();
+          if (now - timestamp > logCutOffLatency) {
+            int rows = rrs == null ? 0 : rrs.length;
+            LOG.info("Took " + (now-timestamp) + "ms to fetch "
+              + rows + " rows from scanner=" + scannerId);
+          }
+        }
       } catch (IOException e) {
+        if (logScannerActivity) {
+          LOG.info("Got exception in fetching from scanner="
+            + scannerId, e);
+        }
         IOException ioe = null;
         if (e instanceof RemoteException) {
           ioe = RemoteExceptionHandler.decodeRemoteException((RemoteException)e);
         }
         if (ioe == null) throw new IOException(e);
+        if (logScannerActivity && (ioe instanceof UnknownScannerException)) {
+          try {
+            HRegionLocation location =
+              connection.relocateRegion(tableName, scan.getStartRow());
+            LOG.info("Scanner=" + scannerId
+              + " expired, current region location is " + location.toString()
+              + " ip:" + location.getServerAddress().getBindAddress());
+          } catch (Throwable t) {
+            LOG.info("Failed to relocate region", t);
+          }
+        }
         if (ioe instanceof NotServingRegionException) {
           // Throw a DNRE so that we break out of cycle of calling NSRE
           // when what we need is to open scanner against new location.
@@ -117,8 +152,14 @@ public class ScannerCallable extends ServerCallable<Result[]> {
   }
 
   protected long openScanner() throws IOException {
-    return this.server.openScanner(this.location.getRegionInfo().getRegionName(),
+    long id = this.server.openScanner(this.location.getRegionInfo().getRegionName(),
       this.scan);
+    if (logScannerActivity) {
+      LOG.info("Open scanner=" + id + " for scan=" + scan.toString()
+        + " on region " + this.location.toString() + " ip:"
+        + this.location.getServerAddress().getBindAddress());
+    }
+    return id;
   }
 
   protected Scan getScan() {
diff --git a/src/main/java/org/apache/hadoop/hbase/mapred/TableRecordReaderImpl.java b/src/main/java/org/apache/hadoop/hbase/mapred/TableRecordReaderImpl.java
index 42569fb..3bf6109 100644
--- a/src/main/java/org/apache/hadoop/hbase/mapred/TableRecordReaderImpl.java
+++ b/src/main/java/org/apache/hadoop/hbase/mapred/TableRecordReaderImpl.java
@@ -23,11 +23,13 @@ import java.io.IOException;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.client.HTable;
 import org.apache.hadoop.hbase.client.Result;
 import org.apache.hadoop.hbase.client.ResultScanner;
 import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.client.ScannerCallable;
 import org.apache.hadoop.hbase.filter.Filter;
 import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
 import org.apache.hadoop.hbase.mapreduce.TableInputFormat;
@@ -35,6 +37,7 @@ import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.hbase.util.Writables;
 import org.apache.hadoop.util.StringUtils;
 
+import static org.apache.hadoop.hbase.mapreduce.TableRecordReaderImpl.LOG_PER_ROW_COUNT;
 
 /**
  * Iterate over an HBase table data, return (Text, RowResult) pairs
@@ -49,6 +52,10 @@ public class TableRecordReaderImpl {
   private ResultScanner scanner;
   private HTable htable;
   private byte [][] trrInputColumns;
+  private long timestamp;
+  private int rowcount;
+  private boolean logScannerActivity = false;
+  private int logPerRowCount = 100000;
 
   /**
    * Restart from survivable exceptions by creating a new scanner.
@@ -57,6 +64,7 @@ public class TableRecordReaderImpl {
    * @throws IOException
    */
   public void restart(byte[] firstRow) throws IOException {
+    Scan currentScan;
     if ((endRow != null) && (endRow.length > 0)) {
       if (trrRowFilter != null) {
         Scan scan = new Scan(firstRow, endRow);
@@ -64,6 +72,7 @@ public class TableRecordReaderImpl {
         scan.setFilter(trrRowFilter);
         scan.setCacheBlocks(false);
         this.scanner = this.htable.getScanner(scan);
+        currentScan = scan;
       } else {
         LOG.debug("TIFB.restart, firstRow: " +
             Bytes.toStringBinary(firstRow) + ", endRow: " +
@@ -71,6 +80,7 @@ public class TableRecordReaderImpl {
         Scan scan = new Scan(firstRow, endRow);
         TableInputFormat.addColumns(scan, trrInputColumns);
         this.scanner = this.htable.getScanner(scan);
+        currentScan = scan;
       }
     } else {
       LOG.debug("TIFB.restart, firstRow: " +
@@ -80,6 +90,12 @@ public class TableRecordReaderImpl {
       TableInputFormat.addColumns(scan, trrInputColumns);
       scan.setFilter(trrRowFilter);
       this.scanner = this.htable.getScanner(scan);
+      currentScan = scan;
+    }
+    if (logScannerActivity) {
+      LOG.info("Current scan=" + currentScan.toString());
+      timestamp = System.currentTimeMillis();
+      rowcount = 0;
     }
   }
 
@@ -99,6 +115,10 @@ public class TableRecordReaderImpl {
    * @param htable the {@link HTable} to scan.
    */
   public void setHTable(HTable htable) {
+    Configuration conf = htable.getConfiguration();
+    logScannerActivity = conf.getBoolean(
+      ScannerCallable.LOG_SCANNER_ACTIVITY, false);
+    logPerRowCount = conf.getInt(LOG_PER_ROW_COUNT, 100000);
     this.htable = htable;
   }
 
@@ -174,32 +194,55 @@ public class TableRecordReaderImpl {
   throws IOException {
     Result result;
     try {
-      result = this.scanner.next();
-    } catch (DoNotRetryIOException e) {
-      throw e;
-    } catch (IOException e) {
-      LOG.debug("recovered from " + StringUtils.stringifyException(e));
-      if (lastSuccessfulRow == null) {
-        LOG.warn("We are restarting the first next() invocation," +
-            " if your mapper's restarted a few other times like this" +
-            " then you should consider killing this job and investigate" +
-            " why it's taking so long.");
-      }
-      if (lastSuccessfulRow == null) {
-        restart(startRow);
-      } else {
-        restart(lastSuccessfulRow);
-        this.scanner.next();    // skip presumed already mapped row
+      try {
+        result = this.scanner.next();
+        if (logScannerActivity) {
+          rowcount ++;
+          if (rowcount >= logPerRowCount) {
+            long now = System.currentTimeMillis();
+            LOG.info("Mapper took " + (now-timestamp)
+              + "ms to process " + rowcount + " rows");
+            timestamp = now;
+            rowcount = 0;
+          }
+        }
+      } catch (DoNotRetryIOException e) {
+        throw e;
+      } catch (IOException e) {
+        LOG.debug("recovered from " + StringUtils.stringifyException(e));
+        if (lastSuccessfulRow == null) {
+          LOG.warn("We are restarting the first next() invocation," +
+              " if your mapper's restarted a few other times like this" +
+              " then you should consider killing this job and investigate" +
+              " why it's taking so long.");
+        }
+        if (lastSuccessfulRow == null) {
+          restart(startRow);
+        } else {
+          restart(lastSuccessfulRow);
+          this.scanner.next();    // skip presumed already mapped row
+        }
+        result = this.scanner.next();
       }
-      result = this.scanner.next();
-    }
 
-    if (result != null && result.size() > 0) {
-      key.set(result.getRow());
-      lastSuccessfulRow = key.get();
-      Writables.copyWritable(result, value);
-      return true;
+      if (result != null && result.size() > 0) {
+        key.set(result.getRow());
+        lastSuccessfulRow = key.get();
+        Writables.copyWritable(result, value);
+        return true;
+      }
+      return false;
+    } catch (IOException ioe) {
+      if (logScannerActivity) {
+        long now = System.currentTimeMillis();
+        LOG.info("Mapper took " + (now-timestamp)
+          + "ms to process " + rowcount + " rows");
+        LOG.info(ioe);
+        String lastRow = lastSuccessfulRow == null ?
+          "null" : Bytes.toStringBinary(lastSuccessfulRow);
+        LOG.info("lastSuccessfulRow=" + lastRow);
+      }
+      throw ioe;
     }
-    return false;
   }
 }
diff --git a/src/main/java/org/apache/hadoop/hbase/mapreduce/TableRecordReaderImpl.java b/src/main/java/org/apache/hadoop/hbase/mapreduce/TableRecordReaderImpl.java
index 9aac136..94c5197 100644
--- a/src/main/java/org/apache/hadoop/hbase/mapreduce/TableRecordReaderImpl.java
+++ b/src/main/java/org/apache/hadoop/hbase/mapreduce/TableRecordReaderImpl.java
@@ -23,12 +23,15 @@ import java.io.IOException;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.DoNotRetryIOException;
 import org.apache.hadoop.hbase.client.HTable;
 import org.apache.hadoop.hbase.client.Result;
 import org.apache.hadoop.hbase.client.ResultScanner;
 import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.client.ScannerCallable;
 import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
+import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.hadoop.util.StringUtils;
 
 /**
@@ -36,7 +39,8 @@ import org.apache.hadoop.util.StringUtils;
  * pairs.
  */
 public class TableRecordReaderImpl {
-
+  public static final String LOG_PER_ROW_COUNT
+    = "hbase.mapreduce.log.scanner.rowcount";
 
   static final Log LOG = LogFactory.getLog(TableRecordReader.class);
 
@@ -46,6 +50,10 @@ public class TableRecordReaderImpl {
   private byte[] lastSuccessfulRow = null;
   private ImmutableBytesWritable key = null;
   private Result value = null;
+  private long timestamp;
+  private int rowcount;
+  private boolean logScannerActivity = false;
+  private int logPerRowCount = 100000;
 
   /**
    * Restart from survivable exceptions by creating a new scanner.
@@ -57,6 +65,11 @@ public class TableRecordReaderImpl {
     Scan newScan = new Scan(scan);
     newScan.setStartRow(firstRow);
     this.scanner = this.htable.getScanner(newScan);
+    if (logScannerActivity) {
+      LOG.info("Current scan=" + newScan.toString());
+      timestamp = System.currentTimeMillis();
+      rowcount = 0;
+    }
   }
 
   /**
@@ -74,6 +87,10 @@ public class TableRecordReaderImpl {
    * @param htable  The {@link HTable} to scan.
    */
   public void setHTable(HTable htable) {
+    Configuration conf = htable.getConfiguration();
+    logScannerActivity = conf.getBoolean(
+      ScannerCallable.LOG_SCANNER_ACTIVITY, false);
+    logPerRowCount = conf.getInt(LOG_PER_ROW_COUNT, 100000);
     this.htable = htable;
   }
 
@@ -130,31 +147,54 @@ public class TableRecordReaderImpl {
     if (key == null) key = new ImmutableBytesWritable();
     if (value == null) value = new Result();
     try {
-      value = this.scanner.next();
-    } catch (DoNotRetryIOException e) {
-      throw e;
-    } catch (IOException e) {
-      LOG.debug("recovered from " + StringUtils.stringifyException(e));
-      if (lastSuccessfulRow == null) {
-        LOG.warn("We are restarting the first next() invocation," +
-            " if your mapper's restarted a few other times like this" +
-            " then you should consider killing this job and investigate" +
-            " why it's taking so long.");
+      try {
+        value = this.scanner.next();
+        if (logScannerActivity) {
+          rowcount ++;
+          if (rowcount >= logPerRowCount) {
+            long now = System.currentTimeMillis();
+            LOG.info("Mapper took " + (now-timestamp)
+              + "ms to process " + rowcount + " rows");
+            timestamp = now;
+            rowcount = 0;
+          }
+        }
+      } catch (DoNotRetryIOException e) {
+        throw e;
+      } catch (IOException e) {
+        LOG.debug("recovered from " + StringUtils.stringifyException(e));
+        if (lastSuccessfulRow == null) {
+          LOG.warn("We are restarting the first next() invocation," +
+              " if your mapper's restarted a few other times like this" +
+              " then you should consider killing this job and investigate" +
+              " why it's taking so long.");
+        }
+        if (lastSuccessfulRow == null) {
+          restart(scan.getStartRow());
+        } else {
+          restart(lastSuccessfulRow);
+          scanner.next();    // skip presumed already mapped row
+        }
+        value = scanner.next();
       }
-      if (lastSuccessfulRow == null) {
-        restart(scan.getStartRow());
-      } else {
-        restart(lastSuccessfulRow);
-        scanner.next();    // skip presumed already mapped row
+      if (value != null && value.size() > 0) {
+        key.set(value.getRow());
+        lastSuccessfulRow = key.get();
+        return true;
       }
-      value = scanner.next();
-    }
-    if (value != null && value.size() > 0) {
-      key.set(value.getRow());
-      lastSuccessfulRow = key.get();
-      return true;
+      return false;
+    } catch (IOException ioe) {
+      if (logScannerActivity) {
+        long now = System.currentTimeMillis();
+        LOG.info("Mapper took " + (now-timestamp)
+          + "ms to process " + rowcount + " rows");
+        LOG.info(ioe);
+        String lastRow = lastSuccessfulRow == null ?
+          "null" : Bytes.toStringBinary(lastSuccessfulRow);
+        LOG.info("lastSuccessfulRow=" + lastRow);
+      }
+      throw ioe;
     }
-    return false;
   }
 
   /**
-- 
1.7.0.4

