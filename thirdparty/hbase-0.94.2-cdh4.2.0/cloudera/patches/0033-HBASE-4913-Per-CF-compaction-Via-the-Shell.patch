From 64957854b624b53157c081a36df11f13b9d5838f Mon Sep 17 00:00:00 2001
From: Gregory Chanan <gchanan@cloudera.com>
Date: Mon, 12 Nov 2012 12:24:40 -0800
Subject: [PATCH 033/202] HBASE-4913 Per-CF compaction Via the Shell

Reason: Feature
Author: Mubarak Seyed and Gregory Chanan
Ref: CDH-7570
---
 .../org/apache/hadoop/hbase/client/HBaseAdmin.java |   88 +++++++++++++++--
 .../apache/hadoop/hbase/ipc/HRegionInterface.java  |   14 +++
 .../hadoop/hbase/regionserver/HRegionServer.java   |   31 ++++++-
 src/main/ruby/hbase/admin.rb                       |   22 +++-
 src/main/ruby/shell/commands/compact.rb            |   20 +++-
 src/main/ruby/shell/commands/major_compact.rb      |   21 +++-
 .../hbase/regionserver/TestCompactionState.java    |  103 +++++++++++++++++---
 7 files changed, 257 insertions(+), 42 deletions(-)

diff --git a/src/main/java/org/apache/hadoop/hbase/client/HBaseAdmin.java b/src/main/java/org/apache/hadoop/hbase/client/HBaseAdmin.java
index 71711c1..f1b804b 100644
--- a/src/main/java/org/apache/hadoop/hbase/client/HBaseAdmin.java
+++ b/src/main/java/org/apache/hadoop/hbase/client/HBaseAdmin.java
@@ -1247,7 +1247,35 @@ public class HBaseAdmin implements Abortable, Closeable {
    */
   public void compact(final byte [] tableNameOrRegionName)
   throws IOException, InterruptedException {
-    compact(tableNameOrRegionName, false);
+    compact(tableNameOrRegionName, null, false);
+  }
+  
+  /**
+   * Compact a column family within a table or region.
+   * Asynchronous operation.
+   *
+   * @param tableOrRegionName table or region to compact
+   * @param columnFamily column family within a table or region
+   * @throws IOException if a remote or network exception occurs
+   * @throws InterruptedException
+   */
+  public void compact(String tableOrRegionName, String columnFamily)
+    throws IOException,  InterruptedException {
+    compact(Bytes.toBytes(tableOrRegionName), Bytes.toBytes(columnFamily));
+  }
+
+  /**
+   * Compact a column family within a table or region.
+   * Asynchronous operation.
+   *
+   * @param tableNameOrRegionName table or region to compact
+   * @param columnFamily column family within a table or region
+   * @throws IOException if a remote or network exception occurs
+   * @throws InterruptedException
+   */
+  public void compact(final byte [] tableNameOrRegionName, final byte[] columnFamily)
+  throws IOException, InterruptedException {
+    compact(tableNameOrRegionName, columnFamily, false);
   }
 
   /**
@@ -1273,7 +1301,36 @@ public class HBaseAdmin implements Abortable, Closeable {
    */
   public void majorCompact(final byte [] tableNameOrRegionName)
   throws IOException, InterruptedException {
-    compact(tableNameOrRegionName, true);
+    compact(tableNameOrRegionName, null, true);
+  }
+  
+  /**
+   * Major compact a column family within a table or region.
+   * Asynchronous operation.
+   *
+   * @param tableNameOrRegionName table or region to major compact
+   * @param columnFamily column family within a table or region
+   * @throws IOException if a remote or network exception occurs
+   * @throws InterruptedException
+   */
+  public void majorCompact(final String tableNameOrRegionName,
+    final String columnFamily) throws IOException, InterruptedException {
+    majorCompact(Bytes.toBytes(tableNameOrRegionName),
+      Bytes.toBytes(columnFamily));
+  }
+
+  /**
+   * Major compact a column family within a table or region.
+   * Asynchronous operation.
+   *
+   * @param tableNameOrRegionName table or region to major compact
+   * @param columnFamily column family within a table or region
+   * @throws IOException if a remote or network exception occurs
+   * @throws InterruptedException
+   */
+  public void majorCompact(final byte [] tableNameOrRegionName,
+    final byte[] columnFamily) throws IOException, InterruptedException {
+    compact(tableNameOrRegionName, columnFamily, true);
   }
 
   /**
@@ -1281,11 +1338,13 @@ public class HBaseAdmin implements Abortable, Closeable {
    * Asynchronous operation.
    *
    * @param tableNameOrRegionName table or region to compact
+   * @param columnFamily column family within a table or region
    * @param major True if we are to do a major compaction.
    * @throws IOException if a remote or network exception occurs
    * @throws InterruptedException
    */
-  private void compact(final byte [] tableNameOrRegionName, final boolean major)
+  private void compact(final byte [] tableNameOrRegionName,
+    final byte[] columnFamily, final boolean major)
   throws IOException, InterruptedException {
     CatalogTracker ct = getCatalogTracker();
     try {
@@ -1295,7 +1354,7 @@ public class HBaseAdmin implements Abortable, Closeable {
         if (regionServerPair.getSecond() == null) {
           throw new NoServerForRegionException(Bytes.toStringBinary(tableNameOrRegionName));
         } else {
-          compact(regionServerPair.getSecond(), regionServerPair.getFirst(), major);
+          compact(regionServerPair.getSecond(), regionServerPair.getFirst(), major, columnFamily);
         }
       } else {
         final String tableName = tableNameString(tableNameOrRegionName, ct);
@@ -1306,7 +1365,7 @@ public class HBaseAdmin implements Abortable, Closeable {
           if (pair.getFirst().isOffline()) continue;
           if (pair.getSecond() == null) continue;
           try {
-            compact(pair.getSecond(), pair.getFirst(), major);
+            compact(pair.getSecond(), pair.getFirst(), major, columnFamily);
           } catch (NotServingRegionException e) {
             if (LOG.isDebugEnabled()) {
               LOG.debug("Trying to" + (major ? " major" : "") + " compact " +
@@ -1322,11 +1381,26 @@ public class HBaseAdmin implements Abortable, Closeable {
   }
 
   private void compact(final ServerName sn, final HRegionInfo hri,
-      final boolean major)
+      final boolean major, final byte [] family)
   throws IOException {
     HRegionInterface rs =
       this.connection.getHRegionConnection(sn.getHostname(), sn.getPort());
-    rs.compactRegion(hri, major);
+    if (family != null) {
+      try {
+        rs.compactRegion(hri, major, family);
+      } catch (IOException ioe) {
+        String notFoundMsg = "java.lang.NoSuchMethodException: org.apache.hadoop.hbase.ipc.HRegionInterface."
+          + "compactRegion(org.apache.hadoop.hbase.HRegionInfo, boolean, [B)";
+        if (ioe.getMessage().contains(notFoundMsg)) {
+          throw new IOException("per-column family compaction not supported on this version "
+            + "of the HBase server.  You may still compact at the table or region level by "
+          	+ "omitting the column family name.  Alternatively, you can upgrade the HBase server");
+        }
+        throw ioe;
+      }
+    } else {
+      rs.compactRegion(hri, major);
+    }
   }
 
   /**
diff --git a/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java b/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java
index d5e329e..9886b3a 100644
--- a/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java
+++ b/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java
@@ -533,6 +533,20 @@ public interface HRegionInterface extends VersionedProtocol, Stoppable, Abortabl
   throws NotServingRegionException, IOException;
 
   /**
+   * Compacts a column-family within a specified region.
+   * Performs a major compaction if specified.
+   * <p>
+   * This method is asynchronous.
+   * @param regionInfo region to compact
+   * @param major true to force major compaction
+   * @param columnFamily column family within a region to compact
+   * @throws NotServingRegionException
+   * @throws IOException
+   */
+  void compactRegion(HRegionInfo regionInfo, boolean major, byte[] columnFamily)
+  throws NotServingRegionException, IOException;
+   
+  /**
    * Replicates the given entries. The guarantee is that the given entries
    * will be durable on the slave cluster if this method returns without
    * any exception.
diff --git a/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java b/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
index 4fdbd5a..720c9d4 100644
--- a/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
+++ b/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java
@@ -2954,16 +2954,41 @@ public class HRegionServer implements HRegionInterface, HBaseRPCErrorHandler,
   @QosPriority(priority=HConstants.HIGH_QOS)
   public void compactRegion(HRegionInfo regionInfo, boolean major)
       throws NotServingRegionException, IOException {
+    compactRegion(regionInfo, major, null);
+  }
+
+  @Override
+  @QosPriority(priority=HConstants.HIGH_QOS)
+  public void compactRegion(HRegionInfo regionInfo, boolean major,  byte[] family)
+      throws NotServingRegionException, IOException {
     checkOpen();
     HRegion region = getRegion(regionInfo.getRegionName());
+    Store store = null;
+    if (family != null) {
+      store = region.getStore(family);
+      if (store == null) {
+        throw new IOException("column family " + Bytes.toString(family) +
+          " does not exist in region " + new String(region.getRegionNameAsString()));
+      }
+    }
+
     if (major) {
-      region.triggerMajorCompaction();
+      if (family != null) {
+        store.triggerMajorCompaction();
+      } else {
+        region.triggerMajorCompaction();
+      }
     }
     LOG.trace("User-triggered compaction requested for region " +
       region.getRegionNameAsString());
-    compactSplitThread.requestCompaction(region, "User-triggered "
-        + (major ? "major " : "") + "compaction",
+    String log = "User-triggered " + (major ? "major " : "") + "compaction";
+    if (family != null) {
+      compactSplitThread.requestCompaction(region, store, log,
         Store.PRIORITY_USER);
+    } else {
+      compactSplitThread.requestCompaction(region, log,
+        Store.PRIORITY_USER);
+    }
   }
 
   /** @return the info server */
diff --git a/src/main/ruby/hbase/admin.rb b/src/main/ruby/hbase/admin.rb
index b6042da..4cf6963 100644
--- a/src/main/ruby/hbase/admin.rb
+++ b/src/main/ruby/hbase/admin.rb
@@ -50,15 +50,25 @@ module Hbase
     end
 
     #----------------------------------------------------------------------------------------------
-    # Requests a table or region compaction
-    def compact(table_or_region_name)
-      @admin.compact(table_or_region_name)
+    # Requests a table or region or column family compaction
+    def compact(table_or_region_name, family)
+      if family == nil
+        @admin.compact(table_or_region_name)
+      else
+        # We are compacting a column family within a region.
+        @admin.compact(table_or_region_name, family)
+      end
     end
 
     #----------------------------------------------------------------------------------------------
-    # Requests a table or region major compaction
-    def major_compact(table_or_region_name)
-      @admin.majorCompact(table_or_region_name)
+    # Requests a table or region or column family major compaction
+    def major_compact(table_or_region_name, family)
+      if family == nil
+        @admin.majorCompact(table_or_region_name)
+      else
+        # We are major compacting a column family within a region or table.
+        @admin.majorCompact(table_or_region_name, family)
+      end
     end
 
     #----------------------------------------------------------------------------------------------
diff --git a/src/main/ruby/shell/commands/compact.rb b/src/main/ruby/shell/commands/compact.rb
index d8f71de..fa0b82e 100644
--- a/src/main/ruby/shell/commands/compact.rb
+++ b/src/main/ruby/shell/commands/compact.rb
@@ -23,14 +23,24 @@ module Shell
     class Compact < Command
       def help
         return <<-EOF
-Compact all regions in passed table or pass a region row
-to compact an individual region
-EOF
+          Compact all regions in passed table or pass a region row
+          to compact an individual region. You can also compact a single column
+          family within a region.
+          Examples:
+          Compact all regions in a table:
+          hbase> compact 't1'
+          Compact an entire region:
+          hbase> compact 'r1'
+          Compact only a column family within a region:
+          hbase> compact 'r1', 'c1'
+          Compact a column family within a table:
+          hbase> compact 't1', 'c1'
+        EOF
       end
 
-      def command(table_or_region_name)
+      def command(table_or_region_name, family = nil)
         format_simple_command do
-          admin.compact(table_or_region_name)
+          admin.compact(table_or_region_name, family)
         end
       end
     end
diff --git a/src/main/ruby/shell/commands/major_compact.rb b/src/main/ruby/shell/commands/major_compact.rb
index 56b081e..325344b 100644
--- a/src/main/ruby/shell/commands/major_compact.rb
+++ b/src/main/ruby/shell/commands/major_compact.rb
@@ -23,14 +23,25 @@ module Shell
     class MajorCompact < Command
       def help
         return <<-EOF
-Run major compaction on passed table or pass a region row
-to major compact an individual region
-EOF
+          Run major compaction on passed table or pass a region row
+          to major compact an individual region. To compact a single
+          column family within a region specify the region name
+          followed by the column family name.
+          Examples:
+          Compact all regions in a table:
+          hbase> major_compact 't1'
+          Compact an entire region:
+          hbase> major_compact 'r1'
+          Compact a single column family within a region:
+          hbase> major_compact 'r1', 'c1'
+          Compact a single column family within a table:
+          hbase> major_compact 't1', 'c1'
+        EOF
       end
 
-      def command(table_or_region_name)
+      def command(table_or_region_name, family = nil)
         format_simple_command do
-          admin.major_compact(table_or_region_name)
+          admin.major_compact(table_or_region_name, family)
         end
       end
     end
diff --git a/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompactionState.java b/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompactionState.java
index 8fc2f59..79594d7 100644
--- a/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompactionState.java
+++ b/src/test/java/org/apache/hadoop/hbase/regionserver/TestCompactionState.java
@@ -60,12 +60,52 @@ public class TestCompactionState {
 
   @Test(timeout=60000)
   public void testMajorCompaction() throws IOException, InterruptedException {
-    compaction("testMajorCompaction", 8, CompactionState.MAJOR);
+    compaction("testMajorCompaction", 8, CompactionState.MAJOR, false);
   }
 
   @Test(timeout=60000)
   public void testMinorCompaction() throws IOException, InterruptedException {
-    compaction("testMinorCompaction", 15, CompactionState.MINOR);
+    compaction("testMinorCompaction", 15, CompactionState.MINOR, false);
+  }
+
+  @Test(timeout=60000)
+  public void testMajorCompactionOnFamily() throws IOException, InterruptedException {
+    compaction("testMajorCompactionOnFamily", 8, CompactionState.MAJOR, true);
+  }
+
+  @Test(timeout=60000)
+  public void testMinorCompactionOnFamily() throws IOException, InterruptedException {
+    compaction("testMinorCompactionOnFamily", 15, CompactionState.MINOR, true);
+  }
+
+  @Test
+  public void testInvalidColumnFamily() throws IOException, InterruptedException {
+    byte [] table = Bytes.toBytes("testInvalidColumnFamily");
+    byte [] family = Bytes.toBytes("family");
+    byte [] fakecf = Bytes.toBytes("fakecf");
+    boolean caughtMinorCompact = false;
+    boolean caughtMajorCompact = false;
+    HTable ht = null;
+    try {
+      ht = TEST_UTIL.createTable(table, family);
+      HBaseAdmin admin = new HBaseAdmin(TEST_UTIL.getConfiguration());
+      try {
+        admin.compact(table, fakecf);
+      } catch (IOException ioe) {
+        caughtMinorCompact = true;
+      }
+      try {
+        admin.majorCompact(table, fakecf);
+      } catch (IOException ioe) {
+        caughtMajorCompact = true;
+      }
+    } finally {
+      if (ht != null) {
+        TEST_UTIL.deleteTable(table);
+      }
+      assertTrue(caughtMinorCompact);
+      assertTrue(caughtMajorCompact);
+    }
   }
 
   /**
@@ -75,27 +115,40 @@ public class TestCompactionState {
    * @param tableName
    * @param flushes
    * @param expectedState
+   * @param singleFamily otherwise, run compaction on all cfs
    * @throws IOException
    * @throws InterruptedException
    */
   private void compaction(final String tableName, final int flushes,
-      final CompactionState expectedState) throws IOException, InterruptedException {
+      final CompactionState expectedState, boolean singleFamily)
+      throws IOException, InterruptedException {
     // Create a table with regions
     byte [] table = Bytes.toBytes(tableName);
     byte [] family = Bytes.toBytes("family");
+    byte [][] families =
+      {family, Bytes.add(family, Bytes.toBytes("2")), Bytes.add(family, Bytes.toBytes("3"))};
     HTable ht = null;
     try {
-      ht = TEST_UTIL.createTable(table, family);
-      loadData(ht, family, 3000, flushes);
+      ht = TEST_UTIL.createTable(table, families);
+      loadData(ht, families, 3000, flushes);
       HRegionServer rs = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0);
       List<HRegion> regions = rs.getOnlineRegions(table);
-      int countBefore = countStoreFiles(regions, family);
+      int countBefore = countStoreFilesInFamilies(regions, families);
+      int countBeforeSingleFamily = countStoreFilesInFamily(regions, family);
       assertTrue(countBefore > 0); // there should be some data files
       HBaseAdmin admin = new HBaseAdmin(TEST_UTIL.getConfiguration());
       if (expectedState == CompactionState.MINOR) {
-        admin.compact(tableName);
+        if (singleFamily) {
+          admin.compact(table, family);
+        } else {
+          admin.compact(table);
+        }
       } else {
-        admin.majorCompact(table);
+        if (singleFamily) {
+          admin.majorCompact(table, family);
+        } else {
+          admin.majorCompact(table);
+        }
       }
       long curt = System.currentTimeMillis();
       long waitTime = 5000;
@@ -126,10 +179,22 @@ public class TestCompactionState {
         // Now, compaction should be done.
         assertEquals(CompactionState.NONE, state);
       }
-      int countAfter = countStoreFiles(regions, family);
+      int countAfter = countStoreFilesInFamilies(regions, families);
+      int countAfterSingleFamily = countStoreFilesInFamily(regions, family);
       assertTrue(countAfter < countBefore);
-      if (expectedState == CompactionState.MAJOR) assertTrue(1 == countAfter);
-      else assertTrue(1 < countAfter);
+      if (!singleFamily) {
+        if (expectedState == CompactionState.MAJOR) assertTrue(families.length == countAfter);
+        else assertTrue(families.length < countAfter);
+      } else {
+        int singleFamDiff = countBeforeSingleFamily - countAfterSingleFamily;
+        // assert only change was to single column family
+        assertTrue(singleFamDiff == (countBefore - countAfter));
+        if (expectedState == CompactionState.MAJOR) {
+          assertTrue(1 == countAfterSingleFamily);
+        } else {
+          assertTrue(1 < countAfterSingleFamily);
+        }
+      }
     } finally {
       if (ht != null) {
         TEST_UTIL.deleteTable(table);
@@ -137,16 +202,20 @@ public class TestCompactionState {
     }
   }
 
-  private static int countStoreFiles(
+  private static int countStoreFilesInFamily(
       List<HRegion> regions, final byte[] family) {
+    return countStoreFilesInFamilies(regions, new byte[][]{family});
+  }
+
+  private static int countStoreFilesInFamilies(List<HRegion> regions, final byte[][] families) {
     int count = 0;
     for (HRegion region: regions) {
-      count += region.getStoreFileList(new byte[][]{family}).size();
+      count += region.getStoreFileList(families).size();
     }
     return count;
   }
-
-  private static void loadData(final HTable ht, final byte[] family,
+  
+  private static void loadData(final HTable ht, final byte[][] families,
       final int rows, final int flushes) throws IOException {
     List<Put> puts = new ArrayList<Put>(rows);
     byte[] qualifier = Bytes.toBytes("val");
@@ -154,7 +223,9 @@ public class TestCompactionState {
       for (int k = 0; k < rows; k++) {
         byte[] row = Bytes.toBytes(random.nextLong());
         Put p = new Put(row);
-        p.add(family, qualifier, row);
+        for (int j = 0; j < families.length; ++j) {
+          p.add(families[ j ], qualifier, row);
+        }
         puts.add(p);
       }
       ht.put(puts);
-- 
1.7.0.4

