From 6f3160189de3c0589c525e359c0958c669250b36 Mon Sep 17 00:00:00 2001
From: Himanshu <himanshu@cloudera.com>
Date: Mon, 17 Dec 2012 12:33:54 -0700
Subject: [PATCH 066/202] HBASE-7017  Backport "[replication] The replication-executor should make sure the file that it is replicating is closed before declaring success on that file" to 0.94
 Reason: Bug
 Author: Devaraj
 Ref: CDH-9521

---
 .../apache/hadoop/hbase/regionserver/wal/HLog.java |   12 ++++----
 .../replication/regionserver/Replication.java      |    4 +-
 .../regionserver/ReplicationSource.java            |   31 ++++++++++++++++----
 .../regionserver/ReplicationSourceManager.java     |   17 +++++++++--
 .../regionserver/TestReplicationSourceManager.java |    2 +-
 5 files changed, 48 insertions(+), 18 deletions(-)

diff --git a/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLog.java b/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLog.java
index 2aa3419..b835855 100644
--- a/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLog.java
+++ b/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLog.java
@@ -634,12 +634,6 @@ public class HLog implements Syncable {
       if (nextWriter instanceof SequenceFileLogWriter) {
         nextHdfsOut = ((SequenceFileLogWriter)nextWriter).getWriterFSDataOutputStream();
       }
-      // Tell our listeners that a new log was created
-      if (!this.listeners.isEmpty()) {
-        for (WALActionsListener i : this.listeners) {
-          i.postLogRoll(oldPath, newPath);
-        }
-      }
 
       synchronized (updateLock) {
         // Clean up current writer.
@@ -655,6 +649,12 @@ public class HLog implements Syncable {
           " for " + FSUtils.getPath(newPath));
         this.numEntries.set(0);
       }
+      // Tell our listeners that a new log was created
+      if (!this.listeners.isEmpty()) {
+        for (WALActionsListener i : this.listeners) {
+          i.postLogRoll(oldPath, newPath);
+        }
+      }
       // Can we delete any of the old log files?
       if (this.outputfiles.size() > 0) {
         if (this.lastSeqWritten.isEmpty()) {
diff --git a/src/main/java/org/apache/hadoop/hbase/replication/regionserver/Replication.java b/src/main/java/org/apache/hadoop/hbase/replication/regionserver/Replication.java
index 3bdbfd3..e5b2f7a 100644
--- a/src/main/java/org/apache/hadoop/hbase/replication/regionserver/Replication.java
+++ b/src/main/java/org/apache/hadoop/hbase/replication/regionserver/Replication.java
@@ -211,12 +211,12 @@ public class Replication implements WALActionsListener,
 
   @Override
   public void preLogRoll(Path oldPath, Path newPath) throws IOException {
-    // Not interested
+    getReplicationManager().preLogRoll(newPath);
   }
 
   @Override
   public void postLogRoll(Path oldPath, Path newPath) throws IOException {
-    getReplicationManager().logRolled(newPath);
+    getReplicationManager().postLogRoll(newPath);
   }
 
   @Override
diff --git a/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java b/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java
index d86e24a..eaf052c 100644
--- a/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java
+++ b/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java
@@ -293,6 +293,18 @@ public class ReplicationSource extends Thread
         }
         continue;
       }
+      boolean currentWALisBeingWrittenTo = false;
+      //For WAL files we own (rather than recovered), take a snapshot of whether the
+      //current WAL file (this.currentPath) is in use (for writing) NOW!
+      //Since the new WAL paths are enqueued only after the prev WAL file
+      //is 'closed', presence of an element in the queue means that
+      //the previous WAL file was closed, else the file is in use (currentPath)
+      //We take the snapshot now so that we are protected against races
+      //where a new file gets enqueued while the current file is being processed
+      //(and where we just finished reading the current file).
+      if (!this.queueRecovered && queue.size() == 0) {
+        currentWALisBeingWrittenTo = true;
+      }
       // Open a reader on it
       if (!openReader(sleepMultiplier)) {
         // Reset the sleep multiplier, else it'd be reused for the next file
@@ -311,7 +323,7 @@ public class ReplicationSource extends Thread
       boolean gotIOE = false;
       currentNbEntries = 0;
       try {
-        if(readAllEntriesToReplicateOrNextFile()) {
+        if(readAllEntriesToReplicateOrNextFile(currentWALisBeingWrittenTo)) {
           continue;
         }
       } catch (IOException ioe) {
@@ -360,7 +372,7 @@ public class ReplicationSource extends Thread
       if (this.isActive() && (gotIOE || currentNbEntries == 0)) {
         if (this.lastLoggedPosition != this.position) {
           this.manager.logPositionAndCleanOldLogs(this.currentPath,
-              this.peerClusterZnode, this.position, queueRecovered);
+              this.peerClusterZnode, this.position, queueRecovered, currentWALisBeingWrittenTo);
           this.lastLoggedPosition = this.position;
         }
         if (sleepForRetries("Nothing to replicate", sleepMultiplier)) {
@@ -369,7 +381,7 @@ public class ReplicationSource extends Thread
         continue;
       }
       sleepMultiplier = 1;
-      shipEdits();
+      shipEdits(currentWALisBeingWrittenTo);
 
     }
     if (this.conn != null) {
@@ -385,11 +397,13 @@ public class ReplicationSource extends Thread
   /**
    * Read all the entries from the current log files and retain those
    * that need to be replicated. Else, process the end of the current file.
+   * @param currentWALisBeingWrittenTo is the current WAL being written to
    * @return true if we got nothing and went to the next file, false if we got
    * entries
    * @throws IOException
    */
-  protected boolean readAllEntriesToReplicateOrNextFile() throws IOException{
+  protected boolean readAllEntriesToReplicateOrNextFile(boolean currentWALisBeingWrittenTo)
+      throws IOException {
     long seenEntries = 0;
     if (this.position != 0) {
       this.reader.seek(this.position);
@@ -436,6 +450,9 @@ public class ReplicationSource extends Thread
         break;
       }
     }
+    if (currentWALisBeingWrittenTo) {
+      return false;
+    }
     // If we didn't get anything and the queue has an object, it means we
     // hit the end of the file for sure
     return seenEntries == 0 && processEndOfFile();
@@ -606,8 +623,10 @@ public class ReplicationSource extends Thread
 
   /**
    * Do the shipping logic
+   * @param currentWALisBeingWrittenTo was the current WAL being (seemingly) 
+   * written to when this method was called
    */
-  protected void shipEdits() {
+  protected void shipEdits(boolean currentWALisBeingWrittenTo) {
     int sleepMultiplier = 1;
     if (this.currentNbEntries == 0) {
       LOG.warn("Was given 0 edits to ship");
@@ -625,7 +644,7 @@ public class ReplicationSource extends Thread
         rrs.replicateLogEntries(Arrays.copyOf(this.entriesArray, currentNbEntries));
         if (this.lastLoggedPosition != this.position) {
           this.manager.logPositionAndCleanOldLogs(this.currentPath,
-              this.peerClusterZnode, this.position, queueRecovered);
+              this.peerClusterZnode, this.position, queueRecovered, currentWALisBeingWrittenTo);
           this.lastLoggedPosition = this.position;
         }
         this.totalReplicatedEdits += currentNbEntries;
diff --git a/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceManager.java b/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceManager.java
index 031849f..c89de9a 100644
--- a/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceManager.java
+++ b/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceManager.java
@@ -145,10 +145,13 @@ public class ReplicationSourceManager {
    * @param id id of the peer cluster
    * @param position current location in the log
    * @param queueRecovered indicates if this queue comes from another region server
+   * @param holdLogInZK if true then the log is retained in ZK
    */
-  public void logPositionAndCleanOldLogs(Path log, String id, long position, boolean queueRecovered) {
+  public void logPositionAndCleanOldLogs(Path log, String id, long position,
+      boolean queueRecovered, boolean holdLogInZK) {
     String key = log.getName();
     this.zkHelper.writeReplicationStatus(key, id, position);
+    if (holdLogInZK) return;
     synchronized (this.hlogsById) {
       SortedSet<String> hlogs = this.hlogsById.get(id);
       if (!queueRecovered && hlogs.first() != key) {
@@ -248,7 +251,7 @@ public class ReplicationSourceManager {
     return this.sources;
   }
 
-  void logRolled(Path newLog) throws IOException {
+  void preLogRoll(Path newLog) throws IOException {
     if (!this.replicating.get()) {
       LOG.warn("Replication stopped, won't add new log");
       return;
@@ -274,9 +277,17 @@ public class ReplicationSourceManager {
     }
 
     this.latestPath = newLog;
+  }
+
+  void postLogRoll(Path newLog) throws IOException {
+    if (!this.replicating.get()) {
+      LOG.warn("Replication stopped, won't add new log");
+      return;
+    }
+
     // This only updates the sources we own, not the recovered ones
     for (ReplicationSourceInterface source : this.sources) {
-      source.enqueueLog(newLog);    
+      source.enqueueLog(newLog);
     }
   }
 
diff --git a/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSourceManager.java b/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSourceManager.java
index 5828154..33ee4d0 100644
--- a/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSourceManager.java
+++ b/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSourceManager.java
@@ -202,7 +202,7 @@ public class TestReplicationSourceManager {
     hlog.rollWriter();
 
     manager.logPositionAndCleanOldLogs(manager.getSources().get(0).getCurrentPath(),
-        "1", 0, false);
+        "1", 0, false, false);
 
     HLogKey key = new HLogKey(hri.getRegionName(), test, seq++,
         System.currentTimeMillis(), HConstants.DEFAULT_CLUSTER_ID);
-- 
1.7.0.4

